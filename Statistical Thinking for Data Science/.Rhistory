}
names < - c(colnames(data))
for(i in 1:length(data)) {
names[i] <- lapply(colnames(data), as.numeric)
}
colnames(data)
names < - colnames(data)
for(i in 1:length(data)) {
names(i) <- lapply(colnames(data), as.numeric)
}
names <- colnames(data)
for(i in 1:length(data)) {
names(i) <- lapply(colnames(data), as.numeric)
}
names
names <- colnames(data)
for(i in 1:length(names)) {
names(i) <- lapply(names, as.numeric)
}
name(2)
names = colnames(data)
names(1)
names[8]
names = colnames(data)
for(i in 1:length(names)) {
names[i] <- lapply(names, as.numeric)
}
names = colnames(data)
for(i in 1:length(names)) {
names[i] = lapply(names, as.numeric)
names[i]= names[i]_NUM
}
names = colnames(data)
for(i in 1:length(names)){
names[i] = lapply(names, as.numeric)
names[i] <- "names[i]_NUM"
}
mode(data$PCIP26_NUM)
data$PCIP26_NUM
names = colnames(data)
for(i in 1:length(names)){
names[i] = lapply(names, as.numeric)
names[i] <- c(names[i],"_NUM")
}
mode(data$PCIP26_NUM)
names[1]
names = colnames(data)
names[1]
length(names)
names[122]
names[1] <- c(names[1], "_NUM")
names[1] <- c("_NUM")
names[1]
names[1]
names[2]
names[2] = lapply(names, as.numeric)
mode(data$names[2])
? mode
#function that calls all the variable names
names = colnames(data)
#For loop that turns variables into numeric and then changes name to columname_NUM
for(i in 1:length(names)){
names[i] = lapply(names, as.numeric)
names[i] <- paste(names[i], "_NUM")
}
names[4]
names[8]
names = colnames(data)
names[1]
f <-function(v) c(v[1]^(3/4)*v[2]^(1/3)+v[1], v[1]^(1/4)*v[2]^(2/3)+v[2])
v0 = c(16,8); f(v0)
A <- jacobian(f, v0); A
install.packages("numDeriv")
library(numDeriv)    #for the grad() function
par(mar = c(2,2,1,1))  #maximize space for graphs
f <-function(v) c(v[1]^(3/4)*v[2]^(1/3)+v[1], v[1]^(1/4)*v[2]^(2/3)+v[2])
v0 = c(16,8); f(v0)
A <- jacobian(f, v0); A
AInv =solve(A); AInv
v1 <- v0 - AInv%*%f(v0); v1; f(v1)
A <- jacobian(f, v1)
v2 <- v1 - solve(A)%*%f(v1); v2; f(v2)
A <- jacobian(f, v2)
v3 <- v2 - solve(A)%*%f(v2); f(v3)
v3
f(v0)
v1 = c(24,24)
v1 <- v0 + AInv%*%f(v0); v1; f(v1)
A <- jacobian(f, v1)
v2 <- v1 - solve(A)%*%f(v1); v2; f(v2)
f(v0 - v1)
v1 = c(24,24)
f(v0 - v1)
v0-v1
f <-function(v) c(v[1]^(3/4)*v[2]^(1/3)+v[1], v[1]^(1/4)*v[2]^(2/3)+v[2])
v0 = c(32,16); f(v0)
A <- jacobian(f, v0); A
AInv =solve(A); AInv
v1 <- v0 + AInv%*%f(v0); v1; f(v1)
A <- jacobian(f, v1)
v2 <- v1 - solve(A)%*%f(v1); v2; f(v2)
f <-function(v) c(v[1]^(3/4)*v[2]^(1/3)+v[1]-32, v[1]^(1/4)*v[2]^(2/3)+v[2]-16)
v0 = c(16,8); f(v0)
A <- jacobian(f, v0); A
AInv =solve(A); AInv
v1 <- v0 + AInv%*%f(v0); v1; f(v1)
A <- jacobian(f, v1)
v2 <- v1 - solve(A)%*%f(v1); v2; f(v2)
A <- jacobian(f, v2)
v3 <- v2 - solve(A)%*%f(v2); f(v3)
v3
v1 <- v0 - AInv%*%f(v0); v1; f(v1)
v1 = c(24,24)
v1 <- v0 - AInv%*%f(v0); v1; f(v1)
v0
v1
v1 = c(24,24)
v1
v0
v1 <- v0 - AInv%*%f(v0); v1; f(v1)
v1
f(v0)
v0 = c(14,10); f(v0)
v0 = c(24,24); f(v0)
v0 = c(15,9); f(v0)
A <- jacobian(f, v0); A
AInv =solve(A); AInv
v1 <- v0 - AInv%*%f(v0); v1; f(v1)
A <- jacobian(f, v1)
v2 <- v1 - solve(A)%*%f(v1); v2; f(v2)
A <- jacobian(f, v2)
v3 <- v2 - solve(A)%*%f(v2); f(v3)
v3
f <-function(v) c(v[1]^(3/4)*v[2]^(1/3)+v[1]-24, v[1]^(1/4)*v[2]^(2/3)+v[2]-24)
v0 = c(16,8); f(v0)
A <- jacobian(f, v0); A
AInv =solve(A); AInv
v1 <- v0 - AInv%*%f(v0); v1; f(v1)
A <- jacobian(f, v1)
v2 <- v1 - solve(A)%*%f(v1); v2; f(v2)
A <- jacobian(f, v2)
v3 <- v2 - solve(A)%*%f(v2); f(v3)
v3
f <- function(x) x(x^2 - 1)(x^2 - 4) -1
curve(f(x), from = 1, to = 2)
f <- function(x) x*(x^2 - 1)*(x^2 - 4)-1
f
f(x)
curve(f(x), from = 1, to = 2)
abline(h=0, col = "green")
curve(f(x), from = -5, to = 5)
curve(f(x), from = 1, to = 2)
curve(f(x), from = -5, to = 5)
f <- function(x) x*(x^2 - 1)*(x^2 - 4)-1
f(x)
curve(f(x), from = -5, to = 5)
x0 <- 1.2; f(x0); grad(f, x0)
curve(f(x0) + grad(f, x0)*(x-x0), col = "red", add = TRUE)
x1 <- x0 - f(x0)/grad(f, x0); abline(v = x1, col = "red"); f(x1)
x2 <- x1 - f(x1)/grad(f, x1); abline(v = x2, col = "red", lty = 2); f(x2)
x3 <- x2 - f(x2)/grad(f, x2); abline(v = x3, col = "red", lty = 3); f(x3)
x3
curve(f(x))
curve(f(x) from -4 to 4)
? curve
curve(f(x), from -4 to 4)
curve(f(x), from= -4, to= 4)
x0 <- -2; f(x0); grad(f, x0)
curve(f(x0) + grad(f, x0)*(x-x0), col = "red", add = TRUE)
x1 <- x0 - f(x0)/grad(f, x0); abline(v = x1, col = "red"); f(x1)
#Repeat to improve the approximation
x2 <- x1 - f(x1)/grad(f, x1); abline(v = x2, col = "red", lty = 2); f(x2)
x3 <- x2 - f(x2)/grad(f, x2); abline(v = x3, col = "red", lty = 3); f(x3)
x3
x4 <- -1; f(x4); grad(f, x4)
curve(f(x4) + grad(f, x4)*(x-x4), col = "red", add = TRUE)
x5 <- x4 - f(x4)/grad(f, x4); abline(v = x5, col = "red"); f(x5)
x6 <- x5 - f(x5)/grad(f, x5); abline(v = x6, col = "red", lty = 2); f(x6)
x7 <- x6 - f(x6)/grad(f, x6); abline(v = x7, col = "red", lty = 3); f(x7)
x7
x8 <- 0; f(x8); grad(f, x8)
#Add the tangent line to the plot
curve(f(x8) + grad(f, x8)*(x-x8), col = "red", add = TRUE)
x9 <- x8 - f(x8)/grad(f, x8); abline(v = x9, col = "red"); f(x9)
x10 <- x9 - f(x9)/grad(f, x9); abline(v = x10, col = "red", lty = 2); f(x10)
x11 <- x10 - f(x10)/grad(f, x10); abline(v = x11, col = "red", lty = 3); f(x11)
x11
x12 <- 1; f(x12); grad(f, x12)
curve(f(x12) + grad(f, x12)*(x-x12), col = "red", add = TRUE)
x13 <- x12 - f(x12)/grad(f, x12); abline(v = x13, col = "red"); f(x13)
x14 <- x13 - f(x13)/grad(f, x13); abline(v = x14, col = "red", lty = 2); f(x14)
x15 <- x14 - f(x14)/grad(f, x14); abline(v = x15, col = "red", lty = 3); f(x15)
x15
x16 <- 2; f(x16); grad(f, x16)
curve(f(x16) + grad(f, x16)*(x-x16), col = "red", add = TRUE)
x17 <- x16 - f(x16)/grad(f, x16); abline(v = x17, col = "red"); f(x17)
x18 <- x17 - f(x17)/grad(f, x17); abline(v = x18, col = "red", lty = 2); f(x18)
x19 <- x18 - f(x18)/grad(f, x18); abline(v = x19, col = "red", lty = 3); f(x19)
x19
plot?
?
? plot
? plot()
f <-function(v) c(v[1]^(3/4)*v[2]^(1/3)+v[1]-24, v[1]^(1/4)*v[2]^(2/3)+v[2]-24)
v0 = c(16,8); f(v0)
#The jacobian matrix and its inverse
A <- jacobian(f, v0); A
AInv =solve(A); AInv
#Formula for solving for the approximate solutions to the problem
#v1 = c(24,24)
v1 <- v0 - AInv%*%f(v0); v1; f(v1)
#Repeat to improve the approximation
A <- jacobian(f, v1)
v2 <- v1 - solve(A)%*%f(v1); v2; f(v2)
A <- jacobian(f, v2)
v3 <- v2 - solve(A)%*%f(v2); f(v3)
v3
#Problem 10
#Question: Get all five roots of x(x^2-1)(x^2-4) -1 =0 using Newton's method
#carry out enough iterations to get an error of less than .001
#Define the function
#x(x^2-1)(x^2-4) -1 =0
f <- function(x) x*(x^2 - 1)*(x^2 - 4)-1
f(x)
#graph of function
curve(f(x), from= -4, to= 4)
#Find for value for the first root
x0 <- -2; f(x0); grad(f, x0)
#Add the tangent line to the plot
curve(f(x0) + grad(f, x0)*(x-x0), col = "red", add = TRUE)
#Solve a linear approximation to find where the tangent line is zero
x1 <- x0 - f(x0)/grad(f, x0); abline(v = x1, col = "red"); f(x1)
#Repeat to improve the approximation
x2 <- x1 - f(x1)/grad(f, x1); abline(v = x2, col = "red", lty = 2); f(x2)
x3 <- x2 - f(x2)/grad(f, x2); abline(v = x3, col = "red", lty = 3); f(x3)
x3
#Find a value for the second root
x4 <- -1; f(x4); grad(f, x4)
#Add the tangent line to the plot
curve(f(x4) + grad(f, x4)*(x-x4), col = "red", add = TRUE)
#Solve a linear approximation to find where the tangent line is zero
x5 <- x4 - f(x4)/grad(f, x4); abline(v = x5, col = "red"); f(x5)
#Repeat to improve the approximation
x6 <- x5 - f(x5)/grad(f, x5); abline(v = x6, col = "red", lty = 2); f(x6)
x7 <- x6 - f(x6)/grad(f, x6); abline(v = x7, col = "red", lty = 3); f(x7)
x7
#Find a value for the third root
x8 <- 0; f(x8); grad(f, x8)
#Add the tangent line to the plot
curve(f(x8) + grad(f, x8)*(x-x8), col = "red", add = TRUE)
#Solve a linear approximation to find where the tangent line is zero
x9 <- x8 - f(x8)/grad(f, x8); abline(v = x9, col = "red"); f(x9)
#Repeat to improve the approximation
x10 <- x9 - f(x9)/grad(f, x9); abline(v = x10, col = "red", lty = 2); f(x10)
x11 <- x10 - f(x10)/grad(f, x10); abline(v = x11, col = "red", lty = 3); f(x11)
x11
#Find a value for the fourth root
x12 <- 1; f(x12); grad(f, x12)
#Add the tangent line to the plot
curve(f(x12) + grad(f, x12)*(x-x12), col = "red", add = TRUE)
#Solve a linear approximation to find where the tangent line is zero
x13 <- x12 - f(x12)/grad(f, x12); abline(v = x13, col = "red"); f(x13)
#Repeat to improve the approximation
x14 <- x13 - f(x13)/grad(f, x13); abline(v = x14, col = "red", lty = 2); f(x14)
x15 <- x14 - f(x14)/grad(f, x14); abline(v = x15, col = "red", lty = 3); f(x15)
x15
#Find a value for the fifth root
x16 <- 2; f(x16); grad(f, x16)
#Add the tangent line to the plot
curve(f(x16) + grad(f, x16)*(x-x16), col = "red", add = TRUE)
#Solve a linear approximation to find where the tangent line is zero
x17 <- x16 - f(x16)/grad(f, x16); abline(v = x17, col = "red"); f(x17)
#Repeat to improve the approximation
x18 <- x17 - f(x17)/grad(f, x17); abline(v = x18, col = "red", lty = 2); f(x18)
x19 <- x18 - f(x18)/grad(f, x18); abline(v = x19, col = "red", lty = 3); f(x19)
x19
f <-function(v) c(v[1]^(3/4)*v[2]^(1/3)+v[1]-24, v[1]^(1/4)*v[2]^(2/3)+v[2]-24)
v0 = c(16,8); f(v0)
#The jacobian matrix and its inverse
A <- jacobian(f, v0); A
AInv =solve(A); AInv
#Formula for solving for the approximate solutions to the problem
#v1 = c(24,24)
v1 <- v0 - AInv%*%f(v0); v1; f(v1)
#Repeat to improve the approximation
A <- jacobian(f, v1)
v2 <- v1 - solve(A)%*%f(v1); v2; f(v2)
A <- jacobian(f, v2)
v3 <- v2 - solve(A)%*%f(v2); f(v3)
v3
f <-function(v) c(v[1]^(3/4)*v[2]^(1/3)+v[1]-24, v[1]^(1/4)*v[2]^(2/3)+v[2]-24)
f(c(16,8)) #it works: H(appiness)=22, Cost= 11
x <- seq(from = 12, to = 18, by = 0.6)
y <- seq(from = 6, to = 10, by = 0.2)
V <- function(v) f(v)[1]
z <- matrix(apply(pairs,1,H),length(x)) #apply the happiness function
z <- matrix(apply(pairs,1,V),length(x)) #apply the happiness function
dim(x)
x <- seq(from = 12, to = 18)
y <- seq(from = 6, to = 10)
pairs <- expand.grid(x,y)  #a list of all pairs of values
V <- function(v) f(v)[1]
z <- matrix(apply(pairs,1,V),length(x)) #apply the happiness function
contour( x, y, z, asp = 1, nlevels = 20)    #shows contour lines
#Now do the same for the cost function
P <- function(v) f(v)[2]
z <- matrix(apply(pairs,1,P),length(x))
contour( x, y, z, asp = 1, add = TRUE, col = "red")    #shows contour lines
fJ <- jacobian(f, c(16,8));fJ
fInvJ <- solve(fJ); fInvJ
increment <- c(-8,8)    #happiness 22->19 , cost 11->10
c(16,8)+fInvJ%*%increment
setwd("~/139DreamTeam")
library('data.table')
library('ggplot2')
library('scales')
library('grid')
library('Matrix')
library('foreach')
library('glmnet')
library('lars')
fname=file.choose()
data=read.csv(fname,header=T)
dim(data)
drops <- c("gt_25k_p6","opeid6", "INSTNM","STABBR", "CITY", "INSTURL", "NPCURL", "SATVR25", "SATVR75", "SATMT25", "SATMT75", "SATWR25", "SATWR75", "ACTEN25", "ACTCM25", "ACTCM75", "ACTEN75","ACTMT25", "ACTMT75", "ACTWR25", "ACTWR75", "ACTCMMID", "ACTENMID", "ACTMTMID", "ACTWRMID")
data[drops] <- list(NULL)
convert_to_string <- c("INSTNM","STABBR")
data[,convert_to_string] <- lapply(data[,convert_to_string], as.character)
convert_to_string <- c("INSTNM","STABBR")
data[,convert_to_string] <- lapply(data[,convert_to_string], as.character)
data$CONTROL = as.factor(data$CONTROL)
data$CONTROL = as.factor(data$CONTROL)
convert_to_numeric<- c("RELAFFIL","CURROPER","NPT4_PUB","NPT4_PRIV","NPT41_PUB","NPT42_PUB","NPT43_PUB","NPT44_PUB","NPT45_PUB","NPT41_PRIV","NPT42_PRIV","NPT43_PRIV","NPT44_PRIV","NPT45_PRIV","GRAD_DEBT_MDN_SUPP","GRAD_DEBT_MDN10YR_SUPP","RPY_3YR_RT_SUPP","C150_4_POOLED_SUPP","md_earn_wne_p10", "UNITID", "OPEID","PREDDEG", "C200_L4_POOLED_SUPP","PCTFLOAN","UG25abv","RET_FT4","RET_FTL4","RET_PT4","RET_PTL4","PCTPELL","PPTUG_EF","SATVRMID","SATMTMID","SATWRMID","SAT_AVG","SAT_AVG_ALL","PCIP01","PCIP03","PCIP04","PCIP05","PCIP09","PCIP10","PCIP11","PCIP12","PCIP13","PCIP14","PCIP15","PCIP16","PCIP19","PCIP22","PCIP23","PCIP24","PCIP25","PCIP26","PCIP27","PCIP29","PCIP30","PCIP31","PCIP38","PCIP39","PCIP40","PCIP41","PCIP42","PCIP43","PCIP44","PCIP45","PCIP46","PCIP47","PCIP48","PCIP49","PCIP50","PCIP51","PCIP52","PCIP54","UGDS","UGDS_WHITE","UGDS_BLACK","UGDS_HISP","UGDS_ASIAN","UGDS_AIAN","UGDS_NHPI","UGDS_2MOR","UGDS_NRA","UGDS_UNKN")
data[,convert_to_numeric] <- lapply(data[,convert_to_numeric], as.character)
data[,convert_to_numeric] <- lapply(data[,convert_to_numeric], as.numeric)
hist(data$md_earn_wne_p10)
qqnorm(data$md_earn_wne_p10)
qqline(data$md_earn_wne_p10)
hist(log(data$md_earn_wne_p10))
# the qqplot also looks really good!
qqnorm(log(data$md_earn_wne_p10))
qqline(log(data$md_earn_wne_p10))
ggplot(data, aes(x=md_earn_wne_p10, color=CONTROL, fill=CONTROL, group=CONTROL)) + geom_density(alpha=0.3) + theme_light(base_size=16) + xlab("Median Earnings 10 Years after Matriculation") + ylab("")
ggplot(data, aes(x=log(md_earn_wne_p10), color=CONTROL, fill=CONTROL, group=CONTROL)) + geom_density(alpha=0.3) + theme_light(base_size=16) + xlab("Median Earnings 10 Years after Matriculation") + ylab("")
n = which(names(data) == "md_earn_wne_p10")
which(names(data) == "CONTROL")
n_total = dim(data)[2]
for(i in 1:n_total){
data[is.na(data[,i]),i] = mean(data[,i], na.rm=TRUE)
}
numeric_variables<- c("RELAFFIL","CURROPER","NPT4_PUB","NPT4_PRIV","NPT41_PUB","NPT42_PUB","NPT43_PUB","NPT44_PUB","NPT45_PUB","NPT41_PRIV","NPT42_PRIV","NPT43_PRIV","NPT44_PRIV","NPT45_PRIV","GRAD_DEBT_MDN_SUPP","GRAD_DEBT_MDN10YR_SUPP","RPY_3YR_RT_SUPP","C150_4_POOLED_SUPP","PREDDEG", "C200_L4_POOLED_SUPP","PCTFLOAN","UG25abv","RET_FT4","RET_FTL4","RET_PT4","RET_PTL4","PCTPELL","PPTUG_EF","SATVRMID","SATMTMID","SATWRMID","SAT_AVG","SAT_AVG_ALL","PCIP01","PCIP03","PCIP04","PCIP05","PCIP09","PCIP10","PCIP11","PCIP12","PCIP13","PCIP14","PCIP15","PCIP16","PCIP19","PCIP22","PCIP23","PCIP24","PCIP25","PCIP26","PCIP27","PCIP29","PCIP30","PCIP31","PCIP38","PCIP39","PCIP40","PCIP41","PCIP42","PCIP43","PCIP44","PCIP45","PCIP46","PCIP47","PCIP48","PCIP49","PCIP50","PCIP51","PCIP52","PCIP54","UGDS","UGDS_WHITE","UGDS_BLACK","UGDS_HISP","UGDS_ASIAN","UGDS_AIAN","UGDS_NHPI","UGDS_2MOR","UGDS_NRA","UGDS_UNKN")
significant_variables = glmnet(x=scale(as.matrix(data[numeric_variables])), y=log(data$md_earn_wne_p10),  standardize = T, intercept = F, family = c("gaussian"), alpha = 1)
coef(significant_variables, s=.025)
pairs(~log(md_earn_wne_p10) + PREDDEG + PCTFLOAN + RPY_3YR_RT_SUPP, data = data)
pairs(~log(md_earn_wne_p10) + GRAD_DEBT_MDN_SUPP + GRAD_DEBT_MDN10YR_SUPP + NPT4_PRIV + NPT4_PUB , data = data)
pairs(~log(md_earn_wne_p10) + UGDS_ASIAN +  UGDS + PCIP45, data = data)
pairs(~log(md_earn_wne_p10) + PCIP14 + PCIP12 + SATMTMID + PCTPELL, data = data)
plot(data$RPY_3YR_RT_SUPP, log(data$md_earn_wne_p))
plot((data$RPY_3YR_RT_SUPP * data$RPY_3YR_RT_SUPP) , log(data$md_earn_wne_p))
hist(data$RPY_3YR_RT_SUPP)
plot(data$PCIP14,log(data$md_earn_wne_p10))
plot(log(data$PCIP14),log(data$md_earn_wne_p10))
plot(data$UGDS_ASIAN,log(data$md_earn_wne_p10))
data$RPY_3YR_RT_SUPP = (data$RPY_3YR_RT_SUPP * data$RPY_3YR_RT_SUPP)
data$PCIP14 = log(data$PCIP14 + 1)
v_important = c("md_earn_wne_p10", "UGDS_ASIAN", "UGDS", "PCIP45", "PCIP14", "PCIP12", "SATMTMID", "PCTPELL", "PREDDEG", "PCTFLOAN", "RPY_3YR_RT_SUPP", "GRAD_DEBT_MDN_SUPP", "GRAD_DEBT_MDN10YR_SUPP", "NPT4_PRIV", "NPT4_PUB", "CONTROL", "LOCALE", "region")
data$md_earn_wne_p10 = log(data$md_earn_wne_p10 + 1)
model1 = lm(md_earn_wne_p10 ~ . , data = data[v_important])
summary(model1)
plot(data$md_earn_wne_p10, residuals(model1))
plot(residuals(model1), type = 'l')
plot(data$md_earn_wne_p10, residuals(model1))
plot(model1$residuals~model1$fitted,cex=2,pch=16,col="gray",cex.lab=1.5,cex.main=1.5,main="Residual Scatterplot")
abline(h=0,lwd=2)
plot(model1$residuals~model1$fitted,cex=2,pch=2,col="gray",cex.lab=1.5,cex.main=1.5,main="Residual Scatterplot")
abline(h=0,lwd=2)
plot(model1$residuals~model1$fitted,cex=1,pch=0.5,col="gray",cex.lab=1.5,cex.main=1.5,main="Residual Scatterplot")
abline(h=0,lwd=2)
setwd("~/Documents/Courses/Math 23a/Scripts")
library(numDeriv)
library(numDeriv)
f <- function(x,y) x^3-y^3+2*x*y-5*x+6*y
fVec <- function(v) v[1]^3-v[2]^3+2*v[1]*v[2]-5*v[1]+6*v[2]
contour(x,y,z)
y <- x <- seq(-3, 3, 0.2)
z <- outer(x,y,f)
contour(x,y,z)
x <- seq(-2, 0.5, 0.2)
y <- seq(-1, 2, 0.2)
z <- outer(x,y,f)
contour(x,y,z)
x <- seq(-1.25, -0.5, 0.2)
y <- seq(0.5, 1.5, 0.2)
z <- outer(x,y,f)    #matrix of function values
contour(x,y,z)
x <- seq(-1.05, -0.8, 0.2)
y <- seq(1.1, 1.3, 0.2)
z <- outer(x,y,f)
contour(x,y,z)
x <- seq(-1.5, -0.8, 0.2)
y <- seq(0.5, 1.5, 0.2)
z <- outer(x,y,f)
contour(x,y,z)
x <- seq(-1.5, -0.8, 0.2)
y <- seq(0.7, 1.8, 0.2)
z <- outer(x,y,f)
contour(x,y,z)
x <- seq(-1.25, -0.5, 0.2)
y <- seq(0.7, 1.8, 0.2)
z <- outer(x,y,f)
contour(x,y,z)
contour(x,y,z, levels = c(7,7.02, 7.04, 7.06, 7.08, 7.09, 7.1))
Df <- function(v) c(3*v[1]^2-2*v[2]-5, -3*v[2]^2+2*v[1]+6)
v0 <- c(-1.25, -0.5)
Df(v0)       #pretty close to zero
grad(fVec, v0)   #in fact, we don't need to know our Math 1 stuff!
A <- jacobian(Df, v0); A
hessian(fVec,v0)  #this matrix of second derivatives can be found numerically
v1 <- v0 - solve(A)%*%Df(v0); v1; Df(v1)
f(v1[1], v1[2]) #The local maximum value of the function
v0 <- c(-1.05, -0.95)
Df(v0)       #pretty close to zero
Df <- function(v) c(3*v[1]^2-2*v[2]-5, -3*v[2]^2+2*v[1]+6)
v0 <- c(-1.04, 1.1)
Df(v0)       #pretty close to zero
Df <- function(v) c(3*v[1]^2-2*v[2]-5, -3*v[2]^2+2*v[1]+6)
v0 <- c(-1.03, 1.15)
Df(v0)       #pretty close to zero
Df <- function(v) c(3*v[1]^2-2*v[2]-5, -3*v[2]^2+2*v[1]+6)
v0 <- c(-1.07, 1.15)
Df(v0)       #pretty close to zero
Df <- function(v) c(3*v[1]^2-2*v[2]-5, -3*v[2]^2+2*v[1]+6)
v0 <- c(-1.25, 1.15)
Df(v0)       #pretty close to zero
Df <- function(v) c(3*v[1]^2-2*v[2]-5, -3*v[2]^2+2*v[1]+6)
v0 <- c(-1.01, 1.15)
Df(v0)       #pretty close to zero
Df <- function(v) c(3*v[1]^2-2*v[2]-5, -3*v[2]^2+2*v[1]+6)
v0 <- c(-1.02, 1.1)
Df(v0)       #pretty close to zero
grad(fVec, v0)
A <- jacobian(Df, v0); A
hessian(fVec,v0)  #this matrix of second derivatives can be found numerically
v1 <- v0 - solve(A)%*%Df(v0); v1; Df(v1)
f(v1[1], v1[2]) #The local maximum value of the function
Df <- function(v) c(3*v[1]^2+2*v[2]-5, -3*v[2]^2+2*v[1]+6)
v0 <- c(-1.02, 1.15)
Df(v0)       #pretty close to zero
Df <- function(v) c(3*v[1]^2+2*v[2]-5, -3*v[2]^2+2*v[1]+6)
v0 <- c(-1.5, 1.15)
Df(v0)       #pretty close to zero
Df <- function(v) c(3*v[1]^2+2*v[2]-5, -3*v[2]^2+2*v[1]+6)
v0 <- c(-1.05, 1.15)
Df(v0)       #pretty close to zero
Df <- function(v) c(3*v[1]^2+2*v[2]-5, -3*v[2]^2+2*v[1]+6)
v0 <- c(-1.02, 1.15)
Df(v0)       #pretty close to zero
grad(fVec, v0)
A <- jacobian(Df, v0); A
hessian(fVec,v0)  #this matrix of second derivatives can be found numerically
v1 <- v0 - solve(A)%*%Df(v0); v1; Df(v1)
f(v1[1], v1[2]) #The local maximum value of the function
x <- seq(1, 2.5, 0.2)
y <- seq(-3,-1, 0.2)
z <- outer(x,y,f)
contour(x,y,z)
x <- seq(1.4, 2, 0.2)
y <- seq(-2,-1.7, 0.2)
z <- outer(x,y,f)
contour(x,y,z)
x <- seq(1.4, 2, 0.2)
y <- seq(-2,-1, 0.2)
z <- outer(x,y,f)
contour(x,y,z)
contour(x,y,z, levels = c(-14.5,-14.52, -14.54, -14.56, -14.58, -14.59, -14.6))
Df <- function(v) c(3*v[1]^2+2*v[2]-5, -3*v[2]^2+2*v[1]+6)
v0 <- c(1.65, -1.8)
Df(v0)       #pretty close to zero
Df <- function(v) c(3*v[1]^2+2*v[2]-5, -3*v[2]^2+2*v[1]+6)
v0 <- c(1.7, -1.8)
Df(v0)       #pretty close to zero
Df <- function(v) c(3*v[1]^2+2*v[2]-5, -3*v[2]^2+2*v[1]+6)
v0 <- c(1.7, -1.85)
Df(v0)       #pretty close to zero
Df <- function(v) c(3*v[1]^2+2*v[2]-5, -3*v[2]^2+2*v[1]+6)
v0 <- c(1.7, -1.78)
Df(v0)       #pretty close to zero
Df <- function(v) c(3*v[1]^2+2*v[2]-5, -3*v[2]^2+2*v[1]+6)
v0 <- c(1.7, -1.79)
Df(v0)       #pretty close to zero
grad(fVec, v0)
Df <- function(v) c(3*v[1]^2+2*v[2]-5, -3*v[2]^2+2*v[1]+6)
v0 <- c(1.7, -1.83)
Df(v0)       #pretty close to zero
grad(fVec, v0)
A <- jacobian(Df, v0); A
hessian(fVec,v0)
v1 <- v0 - solve(A)%*%Df(v0); v1; Df(v1)
f(v1[1], v1[2]) #This is the  local maximum value of the function
install.packages(“knitr”)
install.packages('knitr')
setwd("~/Documents/Courses/Statistical Thinking for Data Science")
data(InsectSprays)
dim(InsectSprays)
table(InsectSprays[,"spray"])
pie(table(InsectSprays[,"spray"]))
summary(InsectSprays[,"count"])
hist(InsectSprays[,"count"], xlab="Insect Counts", main="")
plot(count~spray, data=InsectSprays,
xlab="Types of Insecticide",
ylab="Counts of Insects")
anova(lm(count~spray, data=InsectSprays))
